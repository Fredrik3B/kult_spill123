-- Load some default values for our rectangle.
function love.load()
    -- Verden uten gravity
    world = love.physics.newWorld(0, 0, true)
    world:setCallbacks(beginContact, endContact, preSolve, postSolve)

    font = love.graphics.newFont("font.ttf", 32)
    smallFont = love.graphics.newFont("font.ttf", 22)

    gamestate = "start"
    sens = 10
    window_height = love.graphics.getHeight()
    window_width = love.graphics.getWidth()


    math.randomseed(os.time())
    block_x, block_y, block_w, block_h = getBlock()
    shady_block_x, shady_block_y, shady_block_w, shady_block_h = 0, -50, 120, 50
    window_height = love.graphics.getHeight()
    speed = 50

    left_key, right_key = "left", "right"
    points = 0


    -- Spiller og blokker
    objects = {}
    player = {}

    player.img = love.graphics.newImage("images/rakett.png")
    local player_width = player.img:getWidth()
    local player_height = player.img:getHeight()
    player_window_width = window_width - player_width
    player_x, player_y = (window_width-player_width)/2, window_height - player_height - 50
    player.body = love.physics.newBody(world, player_x, player_y, "dynamic")
    -- player.shape = love.physics.newRectangleShape(player_x, player_y)
    -- player_points = {player_x, window_height-200, player_x+player_width, window_height-200, window_width/2, 0}
    player_points = {0, player_height, 0+player_width, player_height, (0+player_width)/2+1, 0, (0+player_width)/2-1, 0}
    player.shape = love.physics.newPolygonShape(player_points)
    player.fixture = love.physics.newFixture(player.body, player.shape)
    player.fixture:setUserData("Player")

    objects.shady_block = {}
    objects.shady_block.attr = "shady"
    objects.shady_block.notSpawn = false
    objects.shady_block.body = love.physics.newBody(world, shady_block_x, shady_block_y, "kinematic") --remember, the shape (the rectangle we create next) anchors to the body from its center, so we have to move it to (650/2, 650-50/2)
    objects.shady_block.shape = love.physics.newRectangleShape(shady_block_w, shady_block_h) --make a rectangle with a width of 650 and a height of 50
    objects.shady_block.fixture = love.physics.newFixture(objects.shady_block.body, objects.shady_block.shape) --attach shape to body


    objects.block = {}
    objects.block.attr = "normal"
    objects.block.body = love.physics.newBody(world, block_x, block_y, "kinematic") --remember, the shape (the rectangle we create next) anchors to the body from its center, so we have to move it to (650/2, 650-50/2)
    objects.block.shape = love.physics.newRectangleShape(block_w, block_h) --make a rectangle with a width of 650 and a height of 50
    objects.block.fixture = love.physics.newFixture(objects.block.body, objects.block.shape) --attach shape to body

end

function getBlock()
    return math.random(0, window_width-120), -50, 120, 50
end

function gameover()
    love.graphics.clear(1, 1, 0, 0.8)
end

function keypresses()
    if love.keyboard.isDown(left_key) then
        x = player.body:getX() - sens
        if x < 0 then
            x = 0
        end
        player.body:setX(x)
    end
    if love.keyboard.isDown(right_key) then
        x = player.body:getX() + sens
        if x > player_window_width then
            x = player_window_width
        end
        player.body:setX(x)
    end

end

function chechIfBlockHitBottom(object)
    local y = object.body:getY()
    print("y", y, window_height)
    if y > window_height then
        x, y, w, h = getBlock()
        object.body:setX(x)
        object.body:setY(y)
        points = points + 1
        print(points)
    end
    if y == -50 then
        if object.attr == "shady" then
            if math.random(1, 300) ~= 1 then
                object.notSpawn = true
            else
                object.notSpawn = false
            end
        end

    end
    --[[ if shady_block_y > window_height then
        shady_block_y = 0 - shady_block_h
        points = points + 1
        if math.random(1, 300) == 1 then
            shady_block_x, shady_block_y, shady_block_w, shady_block_h = getBlock()
        end
    end --]]

end

function speedOnBlocks(object)
    local current_y = object.body:getY()
    local attr = object.attr
    print(current_y, speed, attr)
    if attr == "normal" then
        y = current_y + speed --* dt
    elseif attr == "shady" then
        -- bare spawn shady speedblokker av og til
        if object.notSpawn == false then
            y = current_y
            if y > 100 then
                y = y * (math.ceil(y/500) + 0.1)
            else
                y = y + 2
            end
        else
            y = current_y
        end
    else
        print("object has no attr")
        print(object.attr)
    end
    object.body:setY(y)
end

-- Increase the size of the rectangle every frame.
function love.update(dt)
    if gamestate == "gameover" then
    elseif gamestate == "play" then
        speed = (2 + speed * dt) + (points/70)
        print("speed", speed)

        for i, block in pairs(objects) do
            print("iter")
            speedOnBlocks(block)
            chechIfBlockHitBottom(block)
        end

        keypresses()
        -- print(points)
        world:update(dt)
    end
end



function love.keypressed(key)
    if key == 'escape' then
        love.event.quit() -- Quit the game.
    end
end
function love.mousepressed(x, y, button)
    if button == 1 then
        local mouse_x = love.mouse.getX()
        local mouse_y = love.mouse.getY()
        if mouse_x >= 100 and mouse_x <= 290 then
            if mouse_y >= 100 and mouse_y <= 150 then
                gamestate = "play"
            elseif mouse_y >= 165 and mouse_y <= 215 then
                sens = math.min(sens + 2, 50)
            elseif mouse_y >= 230 and mouse_y <= 280 then
                sens = math.max(sens - 2, 1)
            elseif mouse_y >= 295 and mouse_y <= 345 then
            elseif mouse_y >= 360 and mouse_y <= 410 then
                love.event.quit()
            end
        end
    end
end


-- Draw a coloured rectangle.
function love.draw()
    love.graphics.setBackgroundColor(0.05, 0.18, 0.21, 0.8)

    if gamestate == "play" then
        love.graphics.setColor(0.6, 0.8, 0.9)

        for _, body in pairs(world:getBodies()) do
            for _, fixture in pairs(body:getFixtures()) do
                local shape = fixture:getShape()
                print(shape, "s", shape:getPoints())
                love.graphics.polygon("fill", body:getWorldPoints(shape:getPoints()))

                -- ToDo Draw collision
            end
        end
     --   love.graphics.draw(player.img, player.shape:getPoints())
    elseif gamestate == "start" then

        love.graphics.setColor(0, 0.8, 0.4)
        love.graphics.rectangle("fill", 100, 100, 190, 50)
        love.graphics.setColor(0, 0.4, 0.7)
        love.graphics.rectangle("fill", 100, 165, 190, 50)
        love.graphics.rectangle("fill", 100, 230, 190, 50)
        love.graphics.rectangle("fill", 100, 295, 190, 50)
        love.graphics.setColor(1, 0.0, 0.1)
        love.graphics.rectangle("fill", 100, 360, 190, 50)

        love.graphics.setColor(1, 1, 1)
        love.graphics.setFont(font)
        love.graphics.print("Spill!", 109, 107)
        love.graphics.print("Mer sens", 109, 172)
        love.graphics.print("Mindre sens", 109, 237)
        love.graphics.print("Leaderboard", 109, 302)
        love.graphics.print("Quit", 109, 367)

        love.graphics.setFont(smallFont)
        love.graphics.print("Sens " .. sens, 100, 8)
        if sens == 50 then
            love.graphics.print("Feite Ku! Det holder", 180, 8)
        end

        love.graphics.draw(player.img, 380, 150, 0, 2)
    elseif gamestate == "gameover" then
        love.graphics.clear(1, 1, 0, 0.8)
    end
    love.graphics.setFont(smallFont)
    love.graphics.setColor(0, 0.7, 0.2)
    love.graphics.print("Poeng " .. points, 8, 8)
end

-- Kræsjing
function beginContact(a, b, coll)
    print("kræsj", a, b, coll)
    gamestate = "gameover"
end

function endContact(a, b, coll)
end

function preSolve(a, b, coll)
end

function postSolve(a, b, coll, normalimpulse, tangentimpulse)
end
